
![[Pasted image 20230906170544.png]]
## 前置知识


### 自定义变量

<mark>自定义变量命名前必须加@</mark>

```sql
-- 设置变量
SET @a = 1;

-- 使用
SELECT @1;

-- 设置为字符串
SET @a = 'test';

-- 将值赋值给另一个变量
SET @b = @a;

-- 将查询结构赋值给变量
SET @a = (SELECT m1 FROM t1 LIMIT 1);

-- 另一种方式赋值
SELECT n1 FROM t1 LIMIT 1 INTO @b;

-- 同时给两个变量赋值
SELECT m1, n1 FROM t1 LIMIT 1 INTO @a, @b;
```

### 语句结束分隔符

> 默认的结束分隔符有 `;` `\g` `\G`

可以使用以下语句重新替换掉`;`

`delimiter 结束符号名`

```shell
mysql> delimiter $
# 改了以$为结束符后, ;不会结束，所以下面一下输出三条结果
mysql> SELECT * FROM t1 LIMIT 1;
    -> SELECT * FROM t2 LIMIT 1;
    -> SELECT * FROM t3 LIMIT 1;
    -> $
+------+------+
| m1   | n1   |
+------+------+
|    1 | a    |
+------+------+
1 row in set (0.00 sec)

+------+------+
| m2   | n2   |
+------+------+
|    2 | b    |
+------+------+
1 row in set (0.00 sec)

+------+------+
| m3   | n3   |
+------+------+
|    3 | c    |
+------+------+
1 row in set (0.00 sec)

mysql>
```

注意: 不要使用反斜杠(\)字符作为语句结束分隔符，这是MySQL的转义字符

## 存储函数/存储过程/函数体
### 存储函数

#### 创建存储函数

```sql
CREATE FUNCTION 函数名([参数列表]) 
RETURN 返回值类型
BEGIN
	函数体内容
END
```

注意: mysql的默认配置是不允许创建函数的，需要设置
`SET GLOBAL log_bin_trust_function_creators = 1;`

```shell
## 创建一个根据专业获取这个专业的平均分

## 因为函数要用到;所以要将结束符暂时设置为$
mysql> delimiter $
mysql> CREATE FUNCTION avg_score_by_subject(s VARCHAR(100))
	-> RETURNS DOUBLE
	-> BEGIN
	->	RETURN (SELECT AVG(score) FROM student_score WHERE subject = s);
	-> END $
Query OK, 0 rows affected (0.00 sec)
## 恢复结束符为;
mysql: delimiter ;

## 使用存储函数
mysql> SELECT avg_score_by_subject('地理');
+------------------------------------+ 
| avg_score('地理')                   | 
+------------------------------------+ 
| 73                                 | 
+------------------------------------+ 
1 row in set (0.00 sec)
```

#### 查看/删除存储函数

查看定义了多少存储函数
`SHOW FUNCTION STATUS `


查看具体哪个函数的结构
`SHOW CREATE FUNCTION 函数名`


删除某个函数
`DROP FUNCTION 函数名`

### 存储过程
> 存储过程与存储函数一样是对一些语句的封装。
> - 存储函数侧重执行语句返回一个值
> - 存储过程侧重执行语句


#### 创建存储过程

```sql
CREATE PROCEDURE 存储过程名称([参数列表])
BEGIN
    函数体内容
END
```

与创建存储函数不同的是少了声明返回值类型(RETURNS)

例: 
```shell
# 对t1表插入一条数据操作的存储过程
mysql> delimiter $
mysql> CREATE PROCEDURE t1_operation(
    ->     m1_value INT,
    ->     n1_value CHAR(1)
    -> )
    -> BEGIN
    ->     SELECT * FROM t1;
    ->     INSERT INTO t1(m1, n1) VALUES(m1_value, n1_value);
    ->     SELECT * FROM t1;
    -> END $
Query OK, 0 rows affected (0.00 sec)

mysql> delimiter ;
mysql>

# 使用存储过程
mysql> CALL t1_operation(4, 'd');
+------+------+
| m1   | n1   |
+------+------+
|    1 | a    |
|    2 | b    |
|    3 | c    |
+------+------+
3 rows in set (0.00 sec)

+------+------+
| m1   | n1   |
+------+------+
|    1 | a    |
|    2 | b    |
|    3 | c    |
|    4 | d    |
+------+------+
4 rows in set (0.00 sec)

Query OK, 0 rows affected (0.00 sec)

mysql>
```

#### 查看/删除存储过程

查看定义了多少存储过程
```sql
SHOW PROCEDURE STATUS
```

查看具体哪个函数的结构
````sql
SHOW CREATE PROCEDURE 存储过程名称
````

删除某个函数
```sql
DROP PROCEDURE 存储过程名称
```

#### 存储过程的参数前缀


```sql
CREATE PROCEDURE 存储过程名称([[IN | OUT | INOUT] 参数名 数据类型])
BEGIN
    函数体内容
END
```


|前缀|实际参数是否必须是变量|描述|
|:-:|:-:|:-:|
|`IN`|否|用于调用者向存储过程传递数据，如果IN参数在过程中被修改，调用者不可见。|
|`OUT`|是|用于把存储过程运行过程中产生的数据赋值给OUT参数，存储过程执行结束后，调用者可以访问到OUT参数。|
|`INOUT`|是|综合`IN`和`OUT`的特点，既可以用于调用者向存储过程传递数据，也可以用于存放存储过程中产生的数据以供调用者使用。|


##### IN 前缀 
- 不要求入参必须是变量
- 如果<mark>参数不加前缀默认是 IN</mark>，
- IN前缀不会改变参数

例子:

```shell
# 创建一个存储过程
mysql> delimiter $
mysql> CREATE PROCEDURE p_in (
->     IN arg INT
-> )
-> BEGIN
->     SELECT arg;
->     SET arg = 123;
-> END $
Query OK, 0 rows affected (0.00 sec)

mysql> delimiter ;


# 使用
# 能够读取到入参
mysql> SET @a = 1;
Query OK, 0 rows affected (0.00 sec)

mysql> CALL p_in(@a);
+------+
| arg  |
+------+
|    1 |
+------+
1 row in set (0.00 sec)

Query OK, 0 rows affected (0.00 sec)

# 修改入参不影响实参
mysql> SELECT @a;
+------+
| @a   |
+------+
|    1 |
+------+
1 row in set (0.00 sec)

mysql>
```

##### OUT前缀
- 要求入参是变量
- 读取不到入参的值
- 修改入参影响实参

例子:

```shell
# 创建一个OUT入参的存储过程
mysql> delimiter $
mysql> CREATE PROCEDURE p_out (
->     OUT arg INT
-> )
-> BEGIN
->     SELECT arg;
->     SET arg = 123;
-> END $
Query OK, 0 rows affected (0.00 sec)

mysql> delimiter ;

mysql> SET @b = 2;
Query OK, 0 rows affected (0.00 sec)

# 调用
# select参数读取不到值
mysql> CALL p_out(@b);
+------+
| arg  |
+------+
| NULL |
+------+
1 row in set (0.00 sec)

Query OK, 0 rows affected (0.00 sec)

# 修改入参实参也发生修改
mysql> SELECT @b;
+------+
| @b   |
+------+
|  123 |
+------+
1 row in set (0.00 sec)

mysql>

```

##### INOUT前缀
结合IN和OUT
- 要求入参必须是变量(不然没发修改)
- 可以读取入参
- 修改入参也会改变实参

### 存储函数与存储过程的区别

- **返回值**: 存储结果可以返回多个结果集(通过修改入参)，而存储函数只能返回一个单一的值
- **使用方法**: 存储函数和普通函数一样执行，存储过程需要CALL调用
- **创建**: 存储函数需要在创建时声明返回类型
- **入参**: 存储过程入参有IN/OUT/INOUT前缀选择, 存储函数没有选择(相当于默认IN)

### 函数体

#### 变量

##### 局部自定义变量

在函数体内局部变量必须先要声明

````sql
-- 声明方式
DECLARE 变量名1, 变量名2, ... 数据类型 [DEFAULT 默认值];
````

- 局部变量只在函数体内可访问，函数(存储函数/存储过程)执行完毕后就会销毁
- <mark>局部变量不允许使用@开头命名</mark>
- <mark>声明语句必须要放在其他语句的前面</makr>

举例:
```shell
mysql> delimiter $;
mysql> CREATE FUNCTION var_demo()
-> RETURNS INT
-> BEGIN
# 这里如果不是赋值的话 c 的默认值就是 NULL
# 可以通过设置默认值来指定值
# DECLARE c INT DEFAULT 1;
->     DECLARE c INT;
->     SET c = 5;
->     RETURN c;
-> END $
Query OK, 0 rows affected (0.00 sec)

mysql> delimiter ;

# 使用
mysql> select var_demo();
+------------+
| var_demo() |
+------------+
|          5 |
+------------+
1 row in set (0.00 sec)

```

##### 自定义变量

在函数体内也可以使用自定义变量

例子:

```shell
mysql> delimiter $
mysql>
mysql> CREATE FUNCTION user_defined_var_demo()
    -> RETURNS INT
    -> BEGIN
    ->     SET @abc = 10;
    ->     return @abc;
    -> END $
Query OK, 0 rows affected (0.00 sec)

mysql>
mysql> delimiter ;
mysql> SELECT user_defined_var_demo();
+-------------------------+
| user_defined_var_demo() |
+-------------------------+
|                      10 |
+-------------------------+
1 row in set (0.01 sec)

# 执行完后自定义变量值依然可以查询且发生改变
mysql> SELECT @abc;
+------+
| @abc |
+------+
|   10 |
+------+
1 row in set (0.00 sec)

mysql>
```

#### 函数的参数

````
参数名 数据类型
````

举例:

```sql
CREATE FUNCTION avg_score(s VARCHAR(100))
RETURNS DOUBLE
BEGIN
    RETURN (SELECT AVG(score) FROM student_score WHERE subject = s);
END
```

- 函数的参数不能与函数体内其他 变量名/列名等冲突
- 函数的参数不能指定默认值

#### 判断语句(分支)


```sql
IF 表达式 THEN
    处理语句列表
[ELSEIF 表达式 THEN
    处理语句列表]
... # 这里可以有多个ELSEIF语句
[ELSE
    处理语句列表]
END IF;
```

举例:

```sql
mysql> delimiter $
mysql> CREATE FUNCTION condition_demo(i INT)
-> RETURNS VARCHAR(10)
-> BEGIN
->     DECLARE result VARCHAR(10);
->     IF i = 1 THEN
->         SET result = '结果是1';
->     ELSEIF i = 2 THEN
->         SET result = '结果是2';
->     ELSEIF i = 3 THEN
->         SET result = '结果是3';
->     ELSE
->         SET result = '非法参数';
->     END IF;
->     RETURN result;
-> END $
Query OK, 0 rows affected (0.00 sec)

mysql> delimiter ;
mysql>

```

#### 循环语句

##### WHILE

```sql
WHILE 表达式 DO
    处理语句列表
END WHILE;
```

```sql
mysql> delimiter $
mysql> CREATE FUNCTION sum_all(n INT UNSIGNED)
-> RETURNS INT
-> BEGIN
->     DECLARE result INT DEFAULT 0;
->     DECLARE i INT DEFAULT 1;
->     WHILE i <= n DO
->         SET result = result + i;
->         SET i = i + 1;
->     END WHILE;
->     RETURN result;
-> END $
Query OK, 0 rows affected (0.00 sec)

mysql> delimiter ;
mysql>
```

##### REPEAT

```sql
REPEAT
    处理语句列表
UNTIL 表达式 END REPEAT;
```

```sql
CREATE FUNCTION sum_all(n INT UNSIGNED)
RETURNS INT
BEGIN
    DECLARE result INT DEFAULT 0;
    DECLARE i INT DEFAULT 1;
    REPEAT
        SET result = result + i;
        SET i = i + 1;
    UNTIL i > n END REPEAT;
    RETURN result;
END
```

##### LOOP

```sql
LOOP
    处理语句列表
END LOOP;
```

- 必须使用 `return`  `LEAVE` 种植循环

```sql
CREATE FUNCTION sum_all(n INT UNSIGNED)
RETURNS INT
BEGIN
    DECLARE result INT DEFAULT 0;
    DECLARE i INT DEFAULT 1;
    LOOP
        IF i > n THEN
        -- 使用 return 返回函数结果并中断循环
            RETURN result;
        END IF;
        SET result = result + i;
        SET i = i + 1;
    END LOOP;
END
```

- LEAVE的语法规则

```sql
CREATE FUNCTION sum_all(n INT UNSIGNED)
RETURNS INT
BEGIN
    DECLARE result INT DEFAULT 0;
    DECLARE i INT DEFAULT 1;
    -- LOOP前必须放置一个标记(不一定是flag这个名)
    flag:LOOP
        IF i > n THEN
            LEAVE flag;
        END IF;
        SET result = result + i;
        SET i = i + 1;
    END LOOP flag;
    RETURN result;
END
```

- 在BEGIN ... END、REPEAT和WHILE这些语句上打标记，标记主要是为了在这些语句发生嵌套时可以跳到指定的语句中使用的。

