
## 整数
> 为了方便计算机的计算，在存储负数时都采用存储该数的补码
> <u>十进制</u>: -6 <u>原码:</u> (1000 1000) <u>反码:</u> (1111 0111) <u>补码: </u> (1111 1000)
> <mark>补码 = 原码的反码 + 1</mark>
> <mark>原码 = (补码 - 1) 的 反码</mark>

| 类型 | 占用的存储空间（单位：字节） | 无符号数取值范围 | 有符号数取值范围 | 含义 |
| --- | --- | --- | --- | --- |
| **tinyint** | 1 | 0 ~ 2⁸-1 | -2⁷ ~ 2⁷-1 | 非常小的整数 |
| **smallint** | 2 | 0 ~ 2¹⁶-1 | -2¹⁵ ~ 2¹⁵-1 | 小的整数 |
| **mediumint** | 3 | 0 ~ 2²⁴-1 | -2²³ ~ 2²³-1 | 中等大小的整数 |
| **integer (int)** | 4 | 0 ~ 2³²-1 | -2³¹ ~ 2³¹-1 | 标准的整数 |
| **bigint** | 8 | 0 ~ 2⁶⁴-1 | -2⁶³ ~ 2⁶³-1 | 大整数 |

## 浮点**数**

| 类型 | 占用的存储空间（单位：字节） | 绝对值最小非0值 | 绝对值最大非0值 |
| --- | --- | --- | --- |
| **float** | 4 | ±1.175494351E-38 | ±3.402823466E+38 |
| **double** | 8 | ±2.2250738585072014E-308 | ±1.7976931348623157E+308 |

### 如何使用二进制保存十进制的浮点数

**例如: 9.875**

---

整数部分(除二取余，逆序)
9
9 = 2 * 4 余 1
4 = 2 * 2 余 0
2 = 2 * 1 余 0
1 = 2 * 1 余 1

**整数部分: 1001**

---

小数部分(乘二取整， 顺序)
0.875
0.875 * 2 = **1**
0.75 * 2 = **1**
0.5 * 2 =** 1**

**小数部分: 111**

---

既 9.875 => 1001.111

---

1001.111转为a × 2ⁿ的科学计数法
1001.111 => 1.001111 * 2^3
其中1.001111中的**001111**就是**尾数**，2^3的**3**是**指数**

---

**所以一个浮点数只需要记录 尾数/指数和符号即可**

- 符号: 一个比特位
- 指数: 视具体浮点数格式而定 (单精8个比特位/双精11个比特位, 按照IEEE754标准)
- 尾数: 视具体浮点数格式而定 (单精23个比特位/双精52个比特位, 按照IEEE754标准)

**IEEE754 标准**

单精度浮点数:
![image.png](https://cdn.nlark.com/yuque/0/2023/png/12973378/1689846214445-ccac2932-3c09-467e-bc24-950de972a8e9.png#averageHue=%232d1e1e&clientId=u4c43276d-6052-4&from=paste&height=75&id=u76ce94be&originHeight=150&originWidth=1180&originalType=binary&ratio=2&rotation=0&showTitle=false&size=21648&status=done&style=none&taskId=uc0bb7694-53cb-441b-9b69-8a023c8903e&title=&width=590)

双精度浮点数:
![image.png](https://cdn.nlark.com/yuque/0/2023/png/12973378/1689846253663-3004678b-9be7-4542-823d-129071d02aea.png#averageHue=%23e5d5d5&clientId=u4c43276d-6052-4&from=paste&height=98&id=uefac976d&originHeight=96&originWidth=594&originalType=binary&ratio=2&rotation=0&showTitle=false&size=7180&status=done&style=none&taskId=u829f136f-f668-4e58-8cf2-e6785ede2d9&title=&width=604)

---

### 浮点数精度问题
> **在计算十进制浮点数的时候会将十进制转为二进制，在转二进制的时候一些浮点数会是无限小数，所以会导致计算结果不准确。**


**例: 0.2 + 0.1 = 0.30000000000000004**

---

0.2转为二进制
0.2
0.2 * 2 = 0
0.4 * 2 = 0
0.8 * 2 = 1
0.6 * 2 = 1
0.2 * 2 = 0
...
0.00110011001100110011...（无限循环）

---

0.1转为二进制
0.1
0.1 * 2 = 0
0.2 * 2 = 0
0.4 * 2 = 0
0.8 * 2 = 1
0.6 * 2 = 1
0.2 * 2 = 0
...
0.000110011001100110011...（无限循环）

---

```javascript
    0.00110011001100110011...   (0.2的二进制表示)
+   0.00011001100110011001...   (0.1的二进制表示)
--------------------------
    0.01001100110011001100...   (相加结果，只保留了一部分计算结果)
转10进制约等于
0.300000000004
```

### 设置最大位数和小数位数

下图是在navcat中设置为double数据类型的xxx字段最大长度为 10, 小数位长度是2，下面还设置了无符号(Unsigned)

![image.png](https://cdn.nlark.com/yuque/0/2023/png/12973378/1689910338210-1721374c-b8dd-408c-a628-af4bd808e8d1.png#averageHue=%23fdfdfd&clientId=u4c43276d-6052-4&from=paste&height=591&id=uacb421e1&originHeight=1182&originWidth=1620&originalType=binary&ratio=2&rotation=0&showTitle=false&size=110269&status=done&style=none&taskId=u87638e9a-824c-45aa-a994-13558359bb9&title=&width=810)

转为sql语句则是

```sql
ALTER TABLE test MODIFY COLUMN `xxx` double(10, 2) UNSIGNED NOT NULL FIRST;
```
```sql
-- M: 代表数的长度 D: 代表小数的长度 (注意是十进制)
-- 123.123 M是6，D是3
-- 0.3 M是0, D是1
-- 其中 M必须大于等于D
-- M的取值范围: 1～255() D的取值范围: 0~30
double(M, D)
float(M, D)
```

## 定点数类型 (DECIMAL)
> 转二进制记录浮点数容易损失精度，定点数类型使用十进制分别记录整数部分和小数部分

例: DEMCIMAL(16, 4)
![image.png](https://cdn.nlark.com/yuque/0/2023/png/12973378/1689912352624-fc72b6fc-3887-4ec8-bf54-b28daade9c4b.png#averageHue=%23f7f2ef&clientId=u1a586d16-e5d5-4&from=paste&height=201&id=u85dd5a83&originHeight=402&originWidth=1397&originalType=binary&ratio=2&rotation=0&showTitle=false&size=86637&status=done&style=none&taskId=u361017eb-cb8f-4f30-9680-c21e9e77182&title=&width=698.5)
第1组包含3个十进制位，需要使用2个字节存储
第2组包含9个十进制位，需要使用4个字节存储
第3组包含4个十进制位，需要使用2个字节存储

```sql
-- 十进制数
1234567890.1234
-- 分组
1 234567890 1234
-- 转为二进制
00000000 00000001
00001101 11111011 00111000 11010010
00000100 11010010
-- 合起来
00000000 00000001 00001101 11111011 00111000 11010010 00000100 11010010
-- 最后最高位要设置为1(暂时不知道原因)
10000000 00000001 00001101 11111011 00111000 11010010 00000100 11010010

```
```sql
-- 在计算机中存储数都是存储补码(方便计算)
-- 如何存这个值的负值 - 取反
-- 例: -5
-- 先算出5的二进制
00000101
-- 取反
11111010
-- 取反后+1
11111011
-- -5的补码为
11111011
```

## 无符号数值类型的表示

```sql
数值类型 UNSIGNED
INT UNSIGNED
```

## 日期和时间类型

MySQL5.6.4版本后的大小用红色字体标识

| 类型 | 存储空间要求 | 取值范围 | 含义 |
| --- | --- | --- | --- |
| YEAR | 1字节 | 1901~2155 | 年份值 |
| DATE | 3字节 | '1000-01-01' ~ '9999-12-31' | 日期值 |
| TIME | 3字节+小数秒的存储空间 | '-838:59:59' ~ '838:59:59' | 时间值 |
| DATETIME | 8字节 (5字节) + 小数秒的存储空间 | '1000-01-01 00:00:00' ～ '9999-12-31 23:59:59' | 日期加时间值 |
| TIMESTAMP | 4字节 + 小数秒的存储空间 | '1970-01-01 00:00:01' ～ '2038-01-19 03:14:07' | 时间戳 |

```sql
-- 支持微秒
类型(小数秒位数)

其中的小数秒位数可以在0、1、2、3、4、5、6中选择
-- 精确到秒
DATETIME(0)
-- 精确到毫秒
DATETIME(3)
-- 精确到10微秒
DATETIME(5)
```

| 保留的小数秒位数 | 额外需要的存储空间要 |
| --- | --- |
| 0 | 0字节 |
| 1或2 | 1字节 |
| 3或4 | 2字节 |
| 5或6 | 3字节 |

## 字符串类型

### 字符
> 正宗的utf8字符集是使用<u>1~4个字节来编码一个字符的</u>，不过MySQL中对utf8字符集做了阉割，编码一个字符最多使用3个字节。如果我们之后有存储使用4个字节来编码的字符的情景，可以使用一种称之为utf8mb4的字符集，它才是正宗的utf8字符集

> 常见的utf8mb4_0900_ai_ci 的意思
> - 字符集: utf8mb4
> - 字符集版本号: 0900
> - 排序规则: ai_ci

### 字符串类型

$\color{red}{M:}$ 代表该数据类型最多能存储的字符数量
$\color{red}{L:}$ 代表**实际**向该类型的属性中存储的字符串在特定字符集下所占的字节数
$\color{red}{W:}$ 代表在该特定字符集下，编码一个字符最多需要的字节数(ascii=1 gbk=2 utf8=3)

| 类型 | 最大长度 | 大小 | 存储空间要求 | 含义 |
| --- | --- | --- | --- | --- |
| CHAR(M) | M个字符 (最大255, 默认1) | 1kb * W | M×W个字节 | 固定长度的字符串 |
| VARCHAR(M) | M个字符 (最大65535) | MxW<256 = 1kb </br> MxW>256 &&MxW<65535 = 2kb | L+1 或 L+2 个字节 | 可变长度的字符串 |
| TINYTEXT | 2⁸-1 个字节 |  | L+1个字节 | 非常小型的字符串 |
| TEXT | 2¹⁶-1 个字节 |  | L+2 个字节 | 小型的字符串 |
| MEDIUMTEXT | 2²⁴-1 个字节 |  | L+3个字节 | 中等大小的字符串 |
| LONGTEXT | 2³²-1 个字节 |  | L+4个字节 | 大型的字符串 |